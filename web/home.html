<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head><link href="ChunkFive/stylesheet.css" rel="stylesheet" type="text/css" /><style>body {font-size:100%;
  font-family: 'Lucida Grande', Verdana, Arial, Helvetica, sans-serif;
  padding: 0; margin: 0;
}
h1 {font: 2.5em 'ChunkFiveRegular', 'LucidaGrande', sans-serif; letter-spacing: 0; line-height: 0;}
h2 {font: 1.5em 'ChunkFiveRegular', 'LucidaGrande', sans-serif; letter-spacing: 0; line-height: 0; margin: 0}
h3 {font: 1.5em 'ChunkFiveRegular', 'LucidaGrande', sans-serif;  }

p {margin-top: 0; margin-bottom: 1em;}
li { margin-bottom: .5em;}

.headline { border-bottom: 1px solid black; padding: .5em; margin: 0; background-color: #E2FDEB; }
.main { padding: 1em;}
.toc { float: left; border: 1px solid black; margin: 0; }
</style></head><body><div class="headline"><h1>TestFirst.org</h1><h2>the home of test-first teaching</h2></div><div class="toc"><li><a href="#welcometotestfirstteaching">Welcome to Test-First Teaching!</a></li><li><a href="#whytestfirstteaching">Why Test-First Teaching?</a></li><li><a href="#unittesting">Unit Testing</a></li><li><a href="#tdd">Test-Driven Development</a></li><li><a href="#testingframeworks">Testing Frameworks</a></li><li><a href="#jointheconversation">Join the Conversation</a></li><li><a href="#installation">Installation</a></li><li><a href="#download">Download</a></li></div><div class="main"><p>This website provides a path to learning Ruby through self-guided exercises that use a software test framework.  This methodology is called &quot;Test First Teaching&quot; and has been applied successfully in a classroom environment.</p><a name="welcometotestfirstteaching"></a><h3>Welcome to Test-First Teaching!</h3><p><strong>Test-First Teaching</strong> follows the example of <a href="#tdd">Test-Driven Development</a>, but with an educational twist. In Test-First Teaching, the student begins with a single unit test (written by the teacher). In order to implement the test, the student has to create source code from scratch. The student then tries to compile and run the test; if the test cannot compile, or if the test runs and fails, then the student must go and fix her error. She then moves on to the next test in the lesson.</p><a name="whytestfirstteaching"></a><h3>Why Test-First Teaching?</h3><p>Test-First Teaching provides a fundamental shift in the way people learn software development. Initially, it helps the student focus on learning very basic syntax, able to independently confirm when they have successfully completed an exercise.  That immediate feedback is valuable for cementing knowledge.</p>

<p>Test-first teaching also teaches an understanding of all of the arcane error messages in a low stress situation.  The first thing you see, before you have written a line of code, is an error.  Then you discover what you need to do to fix that error. Test-first teaching helps people intuitively understand that mistakes are a natural part of the software development process.</p>

<p>In traditional programming exercises, you are either given a fairly large task and asked to implement the whole thing, or you are provided with "skeleton code" -- source code that has been eviscerated to remove key sections, which you are asked to fill in.</p>

<p>"Large task" exercises are often challenging to students because of their sheer size. Many lines of code need to be written before you receive any positive reinforcement. This can be frustrating to beginners, and boring for advanced students.</p>

<p>"Skeleton code" exercises are also frustrating. The task of the student should be to figure out how to write code that will accomplish the given task. With skeleton code, you are first presented with the task of figuring out what the original author was trying to do; of reading through the code (often littered with idiosyncratic idioms and obscure comments); and then of trying to implement just one part of the algorithm, without necessarily understanding the larger picture. If the fill-in-the-blank code section is too complicated, the student may never complete the assignment; if it's too simple, no learning may be gained by the exercise.</p>

<p>Finally, in both types of traditional exercises, as a student you don't really know when you are finished! Sometimes, you will succeed in the task, but neglect to print the results, and will keep at it, believing you are still missing something; other times, you might write code that seems to work but is crucially flawed in some way or another. This is one of the most powerful features of test-first development -- you code until the test passes, and then you stop coding. The test provides a map, informing you of where to begin, and where to end.</p>

<p>Test-first teaching is appropriate for both guided and solo use. Students in a classroom may rely on classmates or teachers for guidance; but if alone, the tests provide some measure of feedback and guidance (although unit tests can never actually debug and fix the code).</p>

<p>Perhaps the most important aspect of test-first teaching is that it teaches the whole process, from opening a new file in a text editor to compiling and running. At the end of the day, the students can say, "At least I know how to write a program." Many exercises, especially skeletons but also those based on tools and toy problems, end up skipping the fundamentals that are vital not just for coding on a day-to-day basis, but also for cementing the higher-level concepts into habits and skills.</p>
<a name="unittesting"></a><h3>Unit Testing</h3><p><strong>Unit Testing</strong> refers to writing a set of functions that sit next to a given module of program code. These functions run a series of tests that assure, more-or-less thoroughly, that the program code performs as it is supposed to.</p>

<p>For example, assume there is a function called add that takes two integers as parameters, adds them together, and returns their sum. There might be one unit test that calls add with 2 and 3, and makes sure the result is 5. There might be additional unit tests that "push the envelope" in various other ways, testing its behavior with large numbers, negative numbers, illegal parameters (e.g. strings), and so forth.</p>

<p>Once a full suite of unit tests is developed, it is good practice to run these tests as often as possible.</p>
<a name="tdd"></a><h3>Test-Driven Development</h3><p><strong>Test-Driven Development</strong> (sometimes called Test-First Development or Test-Driven Design) is the practice of writing the unit tests first, before you write a single line of implementation code. While this may seem like putting the cart before the horse, there are several good reasons why you might want to do this:</p>

<ol>
<li><strong>Design</strong>. It forces you to think first about the design of the interface to the code, instead of jumping straight to the implementation. Having a well-designed interface is often more important than having an efficient implementation.</li>
<li><strong>Discipline</strong>. Writing tests is often seen as a chore; writing the tests first guarantees that at the end of the day you will have written a suite of unit tests (rather than leaving them until the end and possibly never getting around to it).</li>
<li><strong>Reduced Work/Cost</strong>. If you apply a tight cycle of write one test, then write the code to implement that test, then write the next test, your code ends up growing organically. This often (though not always) leads to less wasted effort; you end up writing all the code you need, and none of the code you don't need.</li>
</ol>

<a name="testingframeworks"></a><h3>Testing Frameworks</h3><p>A <strong>Testing Framework</strong> is a tool or library that provides a backdrop for writing tests. For example, to implement a test in the popular JUnit framework, you write a class that extends the common TestCase superclass. Each method in your subclass that begins with the word "test" is a separate unit test. You then run the JUnit tool (both graphical and text versions are provided) and it loads your class and executes each test method in turn, monitoring the results and providing feedback.</p>

<p>There are several testing frameworks in use for Ruby today:</p>

<ul>
<li><code>Test::Unit</code> is included with Ruby 1.8</li>
<li><code>Minitest</code> is included with Ruby 1.9</li>
<li><code>shoulda</code>, which can be used as an extension Test::Unit, provides more readable tests and allows you to write less test code</li>
<li><code>RSpec</code>, which is used in this project, has more concise syntax and can be used in the same project, but creates a separate suite of tests, called "specs"</li>
<li>in <code>Cucumber</code>, tests are written not in Ruby but in a language designed for tests</li>
</ul>

<a name="jointheconversation"></a><h3>Join the Conversation</h3><p>Join our <a href="http://groups.google.com/group/test-first-teaching">google group</a></p><a name="installation"></a><h3>Installation</h3><p>Here are some <a href="http://wiki.devchix.com/index.php?title=Workshop_Installation_Notes">good instructions</a> for installing the required software.  You will need Ruby, RubyGems and Rspec to Learn Ruby.</p><a name="download"></a><h3>Download</h3><ul><li><a href="/pkg/learn_ruby-1.0.0.zip">Learn Ruby</a></li></ul></div></body></html>
