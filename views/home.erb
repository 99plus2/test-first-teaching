<html>
  <h1>Welcome to TestFirst.org</h1>
  <p><strong>Test-First Teaching</strong> follows the example of <a href="#tdd">Test-Driven Development</a>, but with an educational twist. In Test-First Teaching, the student begins with a single unit test (written by the teacher). In order to implement the test, the student has to create source code from scratch. The student then tries to compile and run the test; if the test cannot compile, or if the test runs and fails, then the student must go and fix his error. He then moves on to the next test in the lesson.</p>
<p>Test-First Teaching provides a fundamental shift in the way people learn software development. Initially, it helps the student focus on learning very basic syntax, able to independently confirm when they have successfully completed an exercise.  That immediate feedback is valuable for cementing knowledge.  Test-first teaching also teaches an understanding of all of the arcane error messages in a low stress situation.  The first thing you see, before you have written a line of code, is an error.  Then you discover what you need to do to fix that error.Test-first teaching helps people intuitively understand that mistakes are a natural part of the software development process. </p>
<p>Perhaps the most important aspect of test-first teaching is that it guides the student through the whole process, from opening a new file in a text editor to compiling and running. At the end of the day, the students knows that he or shee has successfully written a program that meets the requirements.</p>

<h2><a name="#tdd">Test Driven Development</a></h2>
<p>Test-First Development (sometimes called Test-Driven Development or Test-Driven Design) is the practice of writing the unit tests first, before you write a single line of implementation code. While this may seem like putting the cart before the horse, there are several good reasons why you might want to do this:</p>
<ol>
<li><strong>Design</strong> It forces you to think first about the design of the interface to the code, instead of jumping straight to the implementation. Having a well-designed interface is often more important than having an efficient implementation.</li>
<li><strong>Project Management</strong> If you apply a tight cycle of write one test, then write the code to implement that test, then write the next test, your code ends up growing organically. This often (though not always) leads to less wasted effort; you end up writing all the code you need, and none of the code you don't need.</li>
<li><strong>Creation of Tests</strong> Writing tests is often seen as a chore; writing the tests first guarantees that at the end of the day you will have written a suite of unit tests (rather than leaving them until the end and possibly never getting around to it).</li>
</ol?
</p>


</html>
